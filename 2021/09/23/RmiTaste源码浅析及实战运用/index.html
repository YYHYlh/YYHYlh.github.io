<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        RmiTaste源码浅析及实战运用 - LH&#39;s blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>

    









<meta name="generator" content="Hexo 6.3.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 常记常新 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar radius">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>LH</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E8%BF%90%E7%94%A8"><span class="toc-text">实战运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 常记常新 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        RmiTaste源码浅析及实战运用
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2021-09-23 18:03:55</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#安全技术" title="安全技术">安全技术</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#源码分析" title="源码分析">源码分析</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <pre><code>本文首发于奇安信攻防社区:https://forum.butian.net/share/1185
</code></pre>
<p>这两天社区里有一位师傅分享了他对JiraCVE-2020-36239的<a target="_blank" rel="noopener" href="https://forum.butian.net/share/653" title="分析">分析</a>，内容写的很详细。于是我跟着他的教程进行了复现，在对RMI进行探测时，师傅说使用了RmiTaste进行检测，没有收到结果。同时我在另一篇分析CVE-2020-36239的文章中看到作者说他用RmiTaste检测时遇到了些问题，简单的patch后，RmiTaste变得可以使用，并且利用RmiTaste完成了后续的攻击。因此我对这个工具的使用产生了兴趣，因此搭建了一个Jira的环境，并进行了复现，中间产生了一些意料之外的问题，比较有意思，因此写下此文记录一下学到的知识，以及遇到的和解决的问题。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>RmiTaste可以帮助广大安全研究专家通过调用ysoserial实用工具所提供的远程方法来检测、枚举、交互和攻击RMI服务。除此之外，它还允许我们使用特定的参数来调用远程方法。</p>
<p>运行RmiTaste，可以看到它存在四种指令</p>
<p><img src="/img/rmitaste/image_EYrHKMmiBn.png"></p>
<ol>
<li>连接。检测到目标服务是否联通</li>
<li>枚举。枚举目标主机中的服务</li>
<li>攻击。使用ysoserial中的序列化链攻击目标主机</li>
<li>调用。调用远程目标服务上的特殊方法。</li>
</ol>
<p>它的四种指令，在代码里对应的是Commands四个类。它们都继承自BasicCommand</p>
<p><img src="/img/rmitaste/image_a3PmMOwaxh.png"></p>
<p>这里顺带说一下RmiTaste的目录结构。</p>
<ul>
<li><p>helpers目录主要是一些IO读写类、命令行参数解析类</p>
<p><img src="/img/rmitaste/image_sXhaeiaEWy.png"></p>
</li>
<li><p>rmitaste目录是主要的代码，下面包含三个目录以及一个入口文件</p>
<ul>
<li><p>commands</p>
<p>四种命令</p>
</li>
<li><p>rmi</p>
<p>和远程主机交互时的连接、处理类</p>
</li>
<li><p>utils</p>
<p>日志相关的工具类</p>
</li>
</ul>
</li>
</ul>
<p>在命令行输入命令，以及其需要的参数，就会调用相应命令类的call函数</p>
<ol>
<li><p>ConnectionCommand执行的命令是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enumerate.connect(<span class="built_in">this</span>.target, <span class="built_in">this</span>.port);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的Enumerate是这个工具处理远程操作的一个总的处理类，它的connect方法，本质上调用的是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">reg</span> <span class="operator">=</span> LocateRegistry.getRegistry(host, port);</span><br></pre></td></tr></table></figure></li>
<li><p>EnumerateCommand是最主要的一个类，它和后面的两个命令类都会调用如下的命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enumerate</span> <span class="variable">enumerate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enumerate</span>(<span class="built_in">this</span>.target, <span class="built_in">this</span>.port);</span><br><span class="line">enumerate.enumerate();</span><br><span class="line"><span class="type">RmiRegistry</span> <span class="variable">rmiRegistry</span> <span class="operator">=</span> enumerate.getRegistry();</span><br></pre></td></tr></table></figure>
<p>其中最主要的就是enumerate.enumerate();，这个函数负责连接目标、获取对象名称和相应的类以及绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enumerate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    <span class="comment">// Connect</span></span><br><span class="line">    <span class="built_in">this</span>.registry = Enumerate.connect(<span class="built_in">this</span>.registry);</span><br><span class="line">    <span class="comment">// Get object names and corresponding classes</span></span><br><span class="line">    <span class="built_in">this</span>.registry.loadObjects();</span><br><span class="line">    <span class="comment">// Get references to objects</span></span><br><span class="line">    <span class="built_in">this</span>.registry.loadObjectRef();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一步connect会生成一个和远程建立了连接的Registry对象，重点是第二步的loadObjects()，它首先会调用registry的list方法，获取目标主机的RMI服务名列表。接着遍历服务名调用lookup方法，这里的lookup方法，不再是RegistryImpl_Stub原生的lookup方法，最主要的区别是，原生的lookup方法，在向目标主机发送了我们期望的服务名后，会直接调用readObject方法，序列化远程主机传过来的对象。但是这样做的前提是我们的classpath中存在目标主机传回来的对象的class文件，否则就会报错。</p>
<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span><span class="number">40001</span>;</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(host, port);</span><br><span class="line">    <span class="keyword">for</span> (String name :registry.list())&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">   Remote r=  registry.lookup(registry.list()[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如上代码去请求jira的远程服务，可以看到在lookup时出错了</p>
<p><img src="/img/rmitaste/image_Nqg-y7lwNJ.png"></p>
<p><img src="/img/rmitaste/image_siTBJ9qrl2.png"></p>
<p>根本原因在于，原生反序列化中会调用Class.forName去获取类，并生成对象。RmiTaste的处理方法是首先通过反射获取输入流里的byte流，然后使用RmiObjectParser去解析并生成对象。RmiObjectParser的解析流程和ObjectInputStream中的解析流程保持一致，但是避免使用class.forName等需要目标类在classpath中的操作，而是将class名作为一个RmiObjectClass对象的属性进行保存，并把所有获取到的类保存到RmiObject对象的classes属性中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RmiObject</span><span class="params">(String nameL)</span>&#123;</span><br><span class="line">    name = nameL;</span><br><span class="line">    classes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, RmiObjectClass&gt;();</span><br><span class="line">    isJMX = <span class="literal">false</span>;</span><br><span class="line">    isDynamicStub = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RmiObjectClass</span><span class="params">(String nameL, <span class="type">boolean</span> isInterface)</span>&#123;</span><br><span class="line">    name = nameL;</span><br><span class="line">    methods = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, RmiObjectMethod&gt;();</span><br><span class="line">    reference = <span class="literal">null</span>;</span><br><span class="line">    simpleClassLoader = <span class="keyword">new</span> <span class="title class_">SimpleClassLoader</span>();</span><br><span class="line">    <span class="built_in">this</span>.isInterface = isInterface;</span><br><span class="line">    <span class="built_in">this</span>.isRemote = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RmiTaste用这样的方式代替了原生的readObject。</p>
<p>接着是第三步loadObjectRef();这里主要是遍历获取到的RmiObject列表，执行真正的RegistryImpl_Stub.lookup方法，以获取远程对象。</p>
<p>至此，和远程服务的交互结束，接下来就是收集到信息的展示。在处理完远程流之后，就会调用RmiObject的toString方法对服务名和类、方法等进行输出，如果在前面第三步中成功获取到了远程对象，那么此处就会打印Method信息，否则，只会打印服务名和绑定的类名</p>
<p><img src="/img/rmitaste/image_nLbn_mLw-B.png"></p>
<p>如果想要读到完整信息，还是需要将目标类也加入classpath中。</p>
</li>
<li><p>AttackCommand是攻击模块，在攻击前同样使用如下代码进行信息收集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enumerate</span> <span class="variable">enumerate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enumerate</span>(<span class="built_in">this</span>.target, <span class="built_in">this</span>.port);</span><br><span class="line">enumerate.enumerate();</span><br><span class="line"><span class="type">RmiRegistry</span> <span class="variable">rmiRegistry</span> <span class="operator">=</span> enumerate.getRegistry();</span><br></pre></td></tr></table></figure>
<p>该模块存在许多参数，允许调用目标单个方法、或者从文件中读多个方法、或者批量执行目标绑定类的方法，以及执行ysoserial中所有的payload、或者指定payload，最终调用反射进行远程调用，同时把恶意代码作为参数传入远程调用中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Attack</span> <span class="variable">attack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Attack</span>(rmiRegistry, payloadGenerator);</span><br><span class="line">attack.attackRegistry(methodsList);</span><br><span class="line">RemoteRef.invoke()</span><br></pre></td></tr></table></figure></li>
<li><p>CallCommand相当于一个工具命令，封装了一些远程调用的方法，通过传入参数进行远程调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Attack</span> <span class="variable">attack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Attack</span>(rmiRegistry);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> attack.invokeMethod(elements.get(<span class="number">2</span>), elements.get(<span class="number">3</span>), elements.get(<span class="number">4</span>), params);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实战运用"><a href="#实战运用" class="headerlink" title="实战运用"></a>实战运用</h3><p>在对Jira的40001端口探测的使用中出现了两个Bug，都是出现在RmiObjectParser的解析过程中，由于这里模拟的是原生的对java字节码的处理，原作者可能考虑的情况不够完全，所以出现了一些问题。在Debug的同时，也学习了很多java字节码相关的知识，因此记录一下。</p>
<ol>
<li><p>Class Desc有一个classAnnotations的属性，在解析目标Class的Desc的时候，程序总是走到TC_STRING的处理流程，然后在获取UTF-String的时候出错，其获取UTF-String的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getUtfShort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="built_in">this</span>.getShort();</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="built_in">this</span>.getBytes(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Short <span class="title function_">getShort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Short</span> <span class="variable">r</span> <span class="operator">=</span> (<span class="type">short</span>) (((<span class="built_in">this</span>.getByte() &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span> ) | (<span class="built_in">this</span>.getByte() &amp;<span class="number">0xFF</span>));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次在解析classAnnotations时，len总会为负数，这个len会用于生成一个new byte[num]数组，由于长度不能为负，程序就会报错。</p>
<p><img src="/img/rmitaste/image_y-9C7GicFW.png"></p>
<p>为了解决这个bug，我进行了抓包，</p>
<p><img src="/img/rmitaste/image_Z7ihJd2q4-.png"></p>
<p>这样的数据看不直观，将返回的数据，从aced开始，复制一部分序列化数据，使用SerializationDumper进行分析，SerializationDumper是一个分析序列化数据流的工具。</p>
<p><img src="/img/rmitaste/image_yW6VVhv8nN.png"></p>
<p><img src="/img/rmitaste/image_6p40LHIRt4.png"></p>
<p>可以看到，SerializationDumper分析出来的classAnnotation中，第一个byte为0x74，对应TC_STRING，然后两个byte标识String的长度，这里的长度为0x99cf，转换为int为39375。但是在RmiTaste的代码中，这里获取String长度使用的是short，这本身也没有错，因为两byte的数字就应该对应short，但是short类型，最大为32767，因此更大的数就会变为负数，导致了bug的产生。这里修复的方法就是新写一个getBigShort函数，直接将两byte的数据转换为int类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer <span class="title function_">getBigShort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> (Integer) (((<span class="built_in">this</span>.getByte() &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span> ) | (<span class="built_in">this</span>.getByte() &amp;<span class="number">0xFF</span>));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二个遇到的问题和国外的那篇jira分析文章的作者遇到的问题相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseClassAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// Skip annotation element</span></span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            b = <span class="built_in">this</span>.getByte();</span><br><span class="line">            <span class="keyword">if</span>(b == TC_ENDBLOCKDATA)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b == TC_REFERENCE)&#123;</span><br><span class="line">                <span class="built_in">this</span>.getInteger();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b == TC_STRING)&#123;</span><br><span class="line">                <span class="built_in">this</span>.getUtfShort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>parseClassAnnotation</code>函数中，如果程序读完了Annotation那么它还会继续循环，因为它使用的是while(true)循环，但是如果此时数据已经读完了，getByte就会返回-1，当然正常情况下b应该会返回TC_ENDBLOCKDATA从而结束循环，但是如第一个bug所示，当Annotation特别大时，更容易会出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Byte <span class="title function_">getByte</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.index &lt; <span class="built_in">this</span>.streamSize)&#123;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.stream.get(<span class="built_in">this</span>.index);</span><br><span class="line">        <span class="built_in">this</span>.index++;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.logger.severe(<span class="string">&quot;No more bytes to read. Limit has been reached!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;#x20;如果你足够清醒，你会意识到<code>classAnnotations</code>表示和类相关的<code>Annotation</code>的描述信息，它在这个工具中后续的流程中其实起不了什么作用，因此如果只是为了让工具正常运行，其实不需要对这个Annotation的读取太过关心，只需要处理好异常就可以了。</p>
<p>因此这里debug的方法也很简单，在parseClassAnnotation的循环中，如果getByte返回了-1，那么直接退出循环即可，而不是继续在循环里读数据。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对这个工具进行分析和使用的起因是社区师傅的一篇Jira漏洞的分析文章。接着就面临了贴近实战的Rmi探测到攻击的实践，在实践的同时遇到了一些现象和问题，通过阅读源码和动态调试去解释现象，解决问题，最后就有了这篇源码浅析以及bug记录的文章。文章中可能存在一些不严谨的地方，希望大家一起讨论一起学习一起进步。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://forum.butian.net/share/653" title="奇安信攻防社区-CVE-2020-36239 - Jira 多款产品RCE漏洞分析 (butian.net)">奇安信攻防社区-CVE-2020-36239 - Jira 多款产品RCE漏洞分析 (butian.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://dozer.nz/posts/CVE-2020-36239-POC-dev" title="Developing an exploit for the Jira Data Center Ehcache RCE (CVE-2020-36239) | dozer.nz">Developing an exploit for the Jira Data Center Ehcache RCE (CVE-2020-36239) | dozer.nz</a></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://giscus.app/client.js"
    data-repo="YYHYlh/YYHYlh.github.io"
    data-repo-id="R_kgDOJjKWvw"
    data-category="Announcements"
    data-category-id="DIC_kwDOJjKWv84CWs3N"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async>
</script>




</html>
